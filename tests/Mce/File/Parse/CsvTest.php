<?php

/*
 * This file is part of the Mce package.
 *
 * (c) Matthew Conger-Eldeen <mceldeen@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Mce\File\Parse;

use \org\bovigo\vfs\vfsStream as vfsStream;
use \org\bovigo\vfs\vfsStreamDirectory as vfsStreamDirectory;
use \org\bovigo\vfs\vfsStreamWrapper as vfsStreamWrapper;

/**
 * Test class for Csv.
 * Generated by PHPUnit on 2012-05-05 at 21:09:12.
 */
class CsvTest extends \PHPUnit_Framework_TestCase {

    /**
     * @var Csv
     */
    protected $csv;

    protected $largeCsv;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        $this->csv = new Csv;
        $this->largeCsv = realpath(__DIR__ . "/../../../data/Large.csv");
        $this->smallCsv = realpath(__DIR__ . "/../../../data/Small.csv");

        vfsStreamWrapper::register();
        vfsStreamWrapper::setRoot(new vfsStreamDirectory('root'));
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {
        unset($this->csv);
    }

    public function testFileNotFoundExceptionWithNonExistentFile() {
        $this->setExpectedException("\\Mce\\File\\Exception\\NotFound");
        $this->csv->parse(vfsStream::url('root/NonExistentFile.csv'));
    }

    public function testFileNotReadableExceptionWithNonReadableFile() {
        $this->setExpectedException("\\Mce\\File\\Exception\\NotReadable");
        vfsStream::newFile('NonReadableFile.csv', 0333)->at(vfsStreamWrapper::getRoot());
        $this->csv->parse(vfsStream::url('root/NonReadableFile.csv'));
    }

    public function testParseReturnsRowsMinusOneWithHeaderRow() {
        $actualRows = 10;
        $rows = $this->csv->parse($this->smallCsv);
        $this->assertTrue($rows == $actualRows, "Csv::parse returned " . $rows . " rows instead of the correct " . $actualRows . " rows.");
    }

    public function testParseReturnsRowsWithoutHeaderRow() {
        $actualRows = 11;
        $rows = $this->csv->parse($this->smallCsv, false);
        $this->assertTrue($rows == $actualRows, "Csv::parse returned " . $rows . " rows instead of the correct " . $actualRows . " rows.");
    }

    public function testSetCallbackReturnsThis() {
        $callback = function($n , $row) { };
        $this->assertTrue($this->csv->setCallback($callback) === $this->csv);
    }

    public function testParseCallsCallbackForEachRow() {
        $rows = 0;
        $callback = function($n , $row) use(&$rows) {
            $rows++;
        };
        $this->csv->setCallback($callback);

        $actualRows = 11;
        $this->csv->parse($this->smallCsv, false);
        $this->assertTrue($rows == $actualRows, "The callback was called for " . $rows . " rows instead of the correct " . $actualRows . " rows.");
    }

    public function testParseCallsCallbackForEachRowExcludingHeader() {
        $rows = 0;
        $callback = function($n , $row) use(&$rows) {
            $rows++;
        };
        $this->csv->setCallback($callback);

        $actualRows = 10;
        $this->csv->parse($this->smallCsv);
        $this->assertTrue($rows == $actualRows, "The callback was called for " . $rows . " rows instead of the correct " . $actualRows . " rows.");
    }

    public function testParseCallsCallbackWithCorrectData() {
        $rows = 0;
        $csvColumns = 3;
        $success = true;
        $callback = function($n , $row) use($csvColumns, &$rows, &$success) {
            if($n !== $rows && count($row) !== $csvColumns) {
                $success = false;
            }
            $rows++;
        };
        $this->csv->setCallback($callback);

        $actualRows = 10;
        $this->csv->parse($this->smallCsv);
        $this->assertTrue($success, "The callback was not passed the correct data.");
    }

    public function testParseUsesHeadersWhenSet() {
        $success = true;
        $callback = function($n, $row) use(&$success) {
            if(!isset($row['foo']) || !isset($row['bar']) || !isset($row['dateTime'])) {
                $success = false;
            }
        };
        $this->csv->setCallback($callback)
                  ->parse($this->smallCsv);
        $this->assertTrue($success, "The correct headers were not set.");
    }

    public function testParseDoesNotUseHeadersWhenNotSet() {
        $success = true;
        $callback = function($n, $row) use(&$success) {
            if(isset($row['foo']) || isset($row['bar']) || isset($row['dateTime'])) {
                $success = false;
            }
        };
        $this->csv->setCallback($callback)
                  ->parse($this->smallCsv, false);
        $this->assertTrue($success, "The headers were set when they weren't supposed to.");
    }

    public function testCanGetErrorMessageWhenValidateHeadersIsSet()
    {
        $parsed = $this->csv
            ->setHeaderValidator(function($columns) {
                if(count($columns) < 4) {
                    return 'Not enough columns';
                }
            })
            ->parse($this->smallCsv, true);

        $this->assertEquals(0, $parsed, 'The validator returned an error, no rows should be parsed');
        $this->assertEquals('Not enough columns', $this->csv->getHeaderError(), 'The error returned should be "Not enough columns"');

        // make sure the error clears
        $parsed = $this->csv->setHeaderValidator(function($columns) { return ""; })->parse($this->smallCsv, true);
        $this->assertEquals(10, $parsed, 'All rows should be parsed the rows correctly');
        $this->assertEquals('', $this->csv->getHeaderError(), 'The error returned should be empty');
    }

    public function testRowValidator()
    {
        $parsed = $this->csv
            ->setValidator(function($row) {
                if(is_numeric($row['foo'])) {
                    return 'Name should not be number';
                }
            })
            ->parse($this->smallCsv, true);


        $this->assertEquals(10, count($this->csv->getErrors()));
        $i = 1;
        foreach($this->csv->getErrors() as $err) {
            $this->assertEquals($i, $err['line'], "Line number should be \"$i\"");
            $this->assertEquals("Name should not be number", $err['message'], "Message should be \"Name should not be number\"");
            $i++;
        }
    }

    public function testRowValidatorSampling()
    {
        $sampled = 0;
        $parsed = $this->csv
            ->setValidateRate(10)
            ->setValidator(function($row) use(&$sampled) {
                $sampled++;
            })
            ->parse($this->largeCsv, true);

        $this->assertEquals(intval(9999 / 10) + 1, $sampled, "The validator should only sample a subset");
    }
}
